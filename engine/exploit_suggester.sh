#!/usr/bin/env bash
# ============================================================================
# RootScope — engine/exploit_suggester.sh
# Cross-references enumeration findings against intelligence databases
# to produce actionable exploitation hints with step-by-step guidance.
# ============================================================================

[[ -n "${_ROOTSCOPE_EXPLOIT_SUGGESTER_LOADED:-}" ]] && return 0
readonly _ROOTSCOPE_EXPLOIT_SUGGESTER_LOADED=1

# ---------------------------------------------------------------------------
# Database paths (set relative to ROOTSCOPE_BASE)
# ---------------------------------------------------------------------------
_init_exploit_db_paths() {
    GTFOBINS_DB="${ROOTSCOPE_BASE}/intelligence/gtfobins.db"
    KERNEL_EXPLOITS_DB="${ROOTSCOPE_BASE}/intelligence/kernel_exploits.db"
    CAPABILITY_EXPLOITS_DB="${ROOTSCOPE_BASE}/intelligence/capability_exploits.db"
    SUID_WHITELIST_DB="${ROOTSCOPE_BASE}/intelligence/suid_whitelist.db"
}

# ---------------------------------------------------------------------------
# GTFOBins lookup
# Check if a binary has known exploitation techniques.
# Usage: check_gtfobins "binary_name" "technique_filter"
#   technique_filter: suid, sudo, capabilities, file-read, file-write, shell, or "all"
# Returns: pipe-delimited matches
# ---------------------------------------------------------------------------
check_gtfobins() {
    local binary="${1}" technique_filter="${2:-all}"
    local db="${GTFOBINS_DB}"

    [[ ! -f "${db}" ]] && return 1

    local basename_bin
    basename_bin=$(basename "${binary}")

    while IFS='|' read -r bin tech cmd sev; do
        # Skip comments and empty lines
        [[ "${bin}" =~ ^#.*$ || -z "${bin}" ]] && continue

        # Match binary name
        if [[ "${bin}" == "${basename_bin}" ]]; then
            # Apply technique filter
            if [[ "${technique_filter}" == "all" || "${tech}" == "${technique_filter}" ]]; then
                echo "GTFOBINS|${bin}|${tech}|${cmd}|${sev}"
            fi
        fi
    done < "${db}"
}

# ---------------------------------------------------------------------------
# Kernel exploit matcher
# Check current kernel version against known exploit ranges.
# Usage: check_kernel_exploits [kernel_version]
# Returns: matching exploit records
# ---------------------------------------------------------------------------
check_kernel_exploits() {
    local current_kernel="${1:-$(uname -r 2>/dev/null)}"
    local db="${KERNEL_EXPLOITS_DB}"

    [[ ! -f "${db}" ]] && return 1

    # Extract major.minor.patch from kernel string (e.g., "5.15.0-91-generic" → "5.15.0")
    local kernel_clean
    kernel_clean=$(echo "${current_kernel}" | grep -oP '^\d+\.\d+\.\d+')
    [[ -z "${kernel_clean}" ]] && return 1

    while IFS='|' read -r kmin kmax cve name desc sev; do
        [[ "${kmin}" =~ ^#.*$ || -z "${kmin}" ]] && continue

        # Version comparison using sort -V
        if _version_in_range "${kernel_clean}" "${kmin}" "${kmax}"; then
            echo "KERNEL_EXPLOIT|${cve}|${name}|${desc}|${sev}|${kmin}-${kmax}"
        fi
    done < "${db}"
}

# ---------------------------------------------------------------------------
# Version range check using sort -V
# Returns 0 if version is within [min, max]
# ---------------------------------------------------------------------------
_version_in_range() {
    local ver="$1" min="$2" max="$3"

    # Check ver >= min
    local lowest
    lowest=$(printf '%s\n%s' "${ver}" "${min}" | sort -V | head -n1)
    [[ "${lowest}" != "${min}" ]] && return 1

    # Check ver <= max (handle "any" as no upper bound)
    if [[ "${max}" != "any" ]]; then
        local highest
        highest=$(printf '%s\n%s' "${ver}" "${max}" | sort -V | tail -n1)
        [[ "${highest}" != "${max}" ]] && return 1
    fi

    return 0
}

# ---------------------------------------------------------------------------
# Capability exploit matcher
# Check if a capability has known exploitation techniques.
# Usage: check_capability_exploits "cap_name" [binary]
# ---------------------------------------------------------------------------
check_capability_exploits() {
    local cap_name="${1}" binary="${2:-}"
    local db="${CAPABILITY_EXPLOITS_DB}"

    [[ ! -f "${db}" ]] && return 1

    # Normalize capability name to lowercase
    local cap_lower
    cap_lower=$(echo "${cap_name}" | tr '[:upper:]' '[:lower:]')

    while IFS='|' read -r cap bin tech sev; do
        [[ "${cap}" =~ ^#.*$ || -z "${cap}" ]] && continue

        if [[ "${cap}" == "${cap_lower}" ]]; then
            echo "CAP_EXPLOIT|${cap}|${bin}|${tech}|${sev}"
        fi
    done < "${db}"
}

# ---------------------------------------------------------------------------
# SUID whitelist check
# Returns 0 if binary is whitelisted (safe), 1 if non-standard.
# Usage: is_suid_whitelisted "/usr/bin/some_binary"
# ---------------------------------------------------------------------------
is_suid_whitelisted() {
    local binary="$1"
    local db="${SUID_WHITELIST_DB}"

    [[ ! -f "${db}" ]] && return 1

    grep -qxF "${binary}" "${db}" 2>/dev/null
}

# ---------------------------------------------------------------------------
# Generate exploitation hint for a finding
# Usage: generate_exploit_hint "finding_type" "target" "extra_context"
# Returns: human-readable exploitation guidance
# ---------------------------------------------------------------------------
generate_exploit_hint() {
    local finding_type="${1}" target="${2}" context="${3:-}"
    local hints=()

    case "${finding_type}" in
        suid_binary)
            local matches
            matches=$(check_gtfobins "${target}" "suid")
            if [[ -n "${matches}" ]]; then
                while IFS='|' read -r _ bin tech cmd sev; do
                    hints+=("GTFOBins ${tech}: ${cmd}")
                done <<< "${matches}"
            fi
            ;;
        sudo_rule)
            local binary
            binary=$(echo "${target}" | awk '{print $NF}')
            local matches
            matches=$(check_gtfobins "${binary}" "sudo")
            if [[ -n "${matches}" ]]; then
                while IFS='|' read -r _ bin tech cmd sev; do
                    hints+=("Sudo exploit: ${cmd}")
                done <<< "${matches}"
            fi
            ;;
        capability)
            local matches
            matches=$(check_capability_exploits "${target}")
            if [[ -n "${matches}" ]]; then
                while IFS='|' read -r _ cap bin tech sev; do
                    hints+=("Capability abuse (${cap}): ${tech}")
                done <<< "${matches}"
            fi
            ;;
        kernel)
            local matches
            matches=$(check_kernel_exploits "${target}")
            if [[ -n "${matches}" ]]; then
                while IFS='|' read -r _ cve name desc sev range; do
                    hints+=("${cve} (${name}): ${desc}")
                done <<< "${matches}"
            fi
            ;;
        writable_file)
            case "${target}" in
                */etc/passwd)  hints+=("Add root-equivalent user: echo 'ruser:openssl_hash:0:0::/root:/bin/bash' >> /etc/passwd") ;;
                */etc/shadow)  hints+=("Replace root password hash or crack existing hashes") ;;
                */etc/crontab) hints+=("Inject reverse shell into cron entry") ;;
                */etc/sudoers) hints+=("Add NOPASSWD ALL rule for current user") ;;
                *)             hints+=("Writable sensitive file — review for privilege escalation vectors") ;;
            esac
            ;;
        docker_socket)
            hints+=("Mount host root: docker run -v /:/mnt --rm -it alpine chroot /mnt sh")
            ;;
        *)
            hints+=("Review finding for potential privilege escalation path")
            ;;
    esac

    # Return joined hints
    if (( ${#hints[@]} > 0 )); then
        local IFS=$'\n'
        echo "${hints[*]}"
    fi
}

# ---------------------------------------------------------------------------
# Batch suggest exploits from parsed findings file
# Usage: suggest_exploits_from_file "parsed_findings_file"
# ---------------------------------------------------------------------------
suggest_exploits_from_file() {
    local findings_file="$1"
    local suggestions=()

    [[ ! -f "${findings_file}" ]] && return 1

    while IFS='|' read -r prefix sev module cat detail hint; do
        [[ "${prefix}" != "FINDING" ]] && continue

        local exploit_type=""
        case "${cat}" in
            *suid*)       exploit_type="suid_binary" ;;
            *sudo*)       exploit_type="sudo_rule" ;;
            *capabilit*)  exploit_type="capability" ;;
            *kernel*)     exploit_type="kernel" ;;
            *writable*)   exploit_type="writable_file" ;;
            *docker*)     exploit_type="docker_socket" ;;
        esac

        if [[ -n "${exploit_type}" ]]; then
            local new_hint
            new_hint=$(generate_exploit_hint "${exploit_type}" "${detail}")
            if [[ -n "${new_hint}" ]]; then
                echo "EXPLOIT_SUGGESTION|${sev}|${module}|${cat}|${detail}|${new_hint}"
            fi
        fi
    done < "${findings_file}"
}
